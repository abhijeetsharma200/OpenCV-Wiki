OpenCV Google Summer of Code (GSoC 2019)
=======================================================
[**:sunny: :fireworks: OpenCV is in! :fireworks: :sunny:**]( https://summerofcode.withgoogle.com/organizations/5654472617885696/)

![OpenCV Ideas Page](https://cdn-images-1.medium.com/max/800/1*VLYFDUP-j-sZB9xphmJxcA.jpeg)

_This is an example from_ [_heartbeat.fritz.ai_](https://heartbeat.fritz.ai/real-time-object-detection-on-raspberry-pi-using-opencv-dnn-98827255fa60) _where Saumya Shovan Roy got DNN object detection working on a Raspberry Pi using OpenCV DNN_

-----------------

OpenCV Project Ideas List:
=========================

| Index | to | Ideas | Below |
| ------------------------ | ------------------------- | -------------- | ----------------- |
| [Circular Calibration](https://github.com/opencv/opencv/wiki/GSoC_2019#idea-calibration-patterns-using-circular-features) | [Data Augmentation](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-computer-vision-data-augmentation-module) | [GPU backend for DNN](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-allow-the-opencv-deep-neural-net-module-dnn-to-work-with-gpus) | [Binary Neural Nets](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-enable-training-and-inference-with-binary-neural-networks) |
| [Model Zoo](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-model-zoo-curate-deep-nets-for-the-DNN) | [Point Coordinate Regression](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-point-coordinate-regression-and-dsac) | [Differential Rendering](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-create-a-differentiable-rendering-module-torchgeometryrender) | [Image Processing](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-differentiable-image-processing) | 
|[April Tags](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-add-april-tag-fiducial-detection-to-opencv)| [Optical Flow](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-create-a-consolidated-optical-flow-module-optflow)| [Python OpenCV](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-improve-and-expand-python-version-of-opencv)| [Depth Fusion](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-kinectfusion-improvements)|
|[Face Landmarks](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-facial-landmark-detector)| [Boosted Cascades](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-a-universal-boosted-cascades-interface)| [Machine Learning Tutorials](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-improve-machine-learning-tutorials-and-documentation)| [OpenCV GUI](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-improve-the-opencv-user-interface)|
| [DNN Quantization](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-add-quantization-and-pruning-functionality-opencv-dnn-module) | [DNN Super-Resolution](https://github.com/opencv/opencv/wiki/GSoC_2019/#idea-deep-learning-based-super-resolution-algorithms-based-on-opencv-dnn) | | |

[ ▶️  **Click here for Mailing List Ideas Discussion** ◀️ ](https://groups.google.com/d/forum/opencv-gsoc-2019) 

* ### All Ideas Below
   1. #### Have these Additional Expected Outcomes:
      * Use the [OpenCV How to Contribute](https://github.com/opencv/opencv/wiki/How_to_contribute) and [Aruco module in opencv_contrib](https://github.com/opencv/opencv_contrib/tree/master/modules/aruco) as a guide.
      * Add unit tests [described here](https://github.com/opencv/opencv/wiki/QA_in_OpenCV), see also the [Aruco test example](https://github.com/opencv/opencv_contrib/tree/master/modules/aruco/test)
      * Add a tutorial, and sample code 
         * see the [Aruco tutorials](https://github.com/opencv/opencv_contrib/tree/master/modules/aruco/tutorials) and how they [look on the web](https://docs.opencv.org/master/d9/d6d/tutorial_table_of_content_aruco.html).
         * See the [Aruco samples](https://github.com/opencv/opencv_contrib/tree/master/modules/aruco/samples)
      * Make a short video showing off your algorithm and post it to Youtube. [Here's an Example](https://www.youtube.com/watch?v=O5P65CYqo_Q).

----

1. ### Area: Calibration
   1. #### _IDEA:_ Calibration Patterns using Circular Features
      * ***Description:*** OpenCV currently allows checkerboard, Aruco, mixed and a basic circular calibration grid. Circular patterns have very good detectability across scale, but the Circular calibration feature in OpenCV is not complete because when a circle is viewed in perspective, the center of the circle is not at the center of mass. This introduces a systematic error into calibration with circular patterns. This can be corrected by compensating for perspective distortion.
      * ***Expected Outcomes:*** 
         * Review the papers on the topic in resources below.
         * Code up a circular calibration module that implements the adjusts the circle center for perspective distortion.
         * Extensive validation (using other patterns and the circular pattern) that shows the circular pattern returning expected intrinsic and distortion camera parameters.
         * Optimizing the module to run efficiently
         * Python interface to the module
         * Resources
            * [Geometric Correction of Circular Fiducials](https://hal-enpc.archives-ouvertes.fr/hal-00990239); direct [pdf link](https://hal-enpc.archives-ouvertes.fr/hal-00990239/document)
            * [Valication Code for Circular Correction](https://github.com/vicrucann/Kmat-virtual)
      * ***Skills Required:*** Solid C++, Coursework and/or experience in camera calibration. Python is a plus because we want calibration to be callable from Python. Mainly, calibration software depends on the details, so being detail oriented is critical as well as the willingness to write thorough test code. 
      * ***Mentors:*** Grace Vesom, Gholamreza Amayeh 
      * ***Difficulty:*** Medium
   
1. ### Area: Data Augmentation
   1. #### _IDEA:_ Computer vision data augmentation module
      * ***Description:*** Deep learning networks are hungry for data and data augmentation is one of the easiest ways to increase data variation. Augmentation could be as simple image flipping, cropping and scaling on up to more complicated transformations such style transfer using another deep learning network. For computer vision problems, OpenCV is often used for reading images in most of training scenarios, so why we'd like to enhance data reading with simple to use data augmentation techniques as well.
      * ***Expected Outcomes:***
         1. Analyze which image transformations are widely used for image classification, object detection, semantic and instance segmentation problems.
            - Things that help with data augmentation for training networks
               - Lighting functions
               - spherical or cylindrical views around a planar object
               - noise ...
               - for 3D point clouds
         1. Create a new OpenCV's module (or use an existing one such `datasets` or `dnn`?) with at least the following functionality:
             - Provide an API to apply single transformations to an Image or batch of Images, Rectangles (i.e. for ground truth for object detection), Masks.
             - Let users combine different transformations in the class object which can apply them with some probability.
             - Custom data transformations which can be included in the augmentation classes.
         1. Write tutorials targeting on Python wrappers due it's the most popular language supported by different DL frameworks right now.
             - These should in particular show use with PyTorch and TensorFlow.
      * ***Skills Required:*** Experience in image processing and deep learning networks training for computer vision problems.
      * ***Mentors:*** Dmitry Kurtaev
      * ***Difficulty:*** Medium

1. ### Area: Deep Learning
   1. #### _IDEA:_ Allow the OpenCV Deep Neural Net Module (DNN) to work with GPUs
      * ***Description:*** The [OpenCV Deep Neural Network (DNN) Module](https://github.com/opencv/opencv/tree/master/modules/dnn) takes [deepnets found on the net]((https://github.com/opencv/opencv/wiki/Deep-Learning-in-OpenCV)) and runs them [5x faster than Pytorch or Tensorflow](https://github.com/opencv/opencv/wiki/DNN-Efficiency) on CPUs. Programmers find DNN [simple to use with powerful results](https://www.learnopencv.com/hand-keypoint-detection-using-deep-learning-and-opencv/). But, DNN is missing an NVidia GPU backend. This project aims at adding that missing GPU backend. 
      * ***Expected Outcomes:*** 
         * Developed plan to port the existing CPU backend to support GPU
            * Review tools [NVidia here](https://developer.nvidia.com/how-to-cuda-c-cpp), [Kokkos here](https://github.com/kokkos/kokkos), [RAJA here](https://github.com/LLNL/RAJA), [OpenCL here](https://www.khronos.org/opencl/), and [CUDA here](https://developer.nvidia.com/cuda-zone).
         * Implemented the new GPU backend for DNN
         * A test suite that compares CPU results with GPU results and makes sure they are close 
         * Performance as fast or faster than native use of nets on GPUs with TensorFlow and Pytorch
         * Resources
            * In general, you can leverage the [CUDA backend for Torch](https://pytorch.org/docs/stable/cuda.html) or DLib (Mentor has info) 
            * [DNN Module](https://github.com/opencv/opencv/tree/master/modules/dnn)
            * [DNN Tutorials](https://docs.opencv.org/master/d2/d58/tutorial_table_of_content_dnn.html)
            * [DNN Wiki -- what's in it](https://github.com/opencv/opencv/wiki/Deep-Learning-in-OpenCV)
            * [DNN Efficiency](https://github.com/opencv/opencv/wiki/DNN-Efficiency)
            * [DNN TensorFlow API](https://github.com/opencv/opencv/wiki/TensorFlow-Object-Detection-API)
            * [DNN Backend Description](https://github.com/opencv/opencv/wiki/Intel%27s-Deep-Learning-Inference-Engine-backend)
      * ***Skills Required:*** 
          * **Must have C++ mastery**
          * Good to have:
             * Python and python interface tools for C++ code, 
             * GPU/Cuda working experience, 
             * coursework or professional work with Deep Nets, 
             * Addional plus if you've optimized code before.
      * ***Mentors:*** Davis King (Dlib creator)
      * ***Difficulty:*** Medium-Hard (not hard if you know the tools/have worked with GPUs and C++ before)
   1. #### _IDEA:_ Enable Training and Inference with Binary Neural Networks
      * ***Description:*** Implement elementary building blocks for binary convolutional neural networks (binary activations and binary weights) for CPU with predictor and trainer modules.
      * ***Expected Outcomes:*** 
         * Inference module for binary convolutional layers.
         * Trainer module for training ensemble of the networks.
         * Exporter to generate self-contained network code with parameters (weights, etc.)
         * Resources
            * paper: https://arxiv.org/abs/1602.02830
            * paper: https://arxiv.org/abs/1809.03368 
            * paper: https://arxiv.org/abs/1603.05279
      * ***Skills Required:*** Skills Required: Coding in C/C++, speed optimization, multi-threading, random number generators, probabilities, Bayesian inference.
      * ***Mentors:*** Michael Tetelman
      * ***Difficulty:*** Medium/Hard

   1. #### _IDEA:_ Model Zoo Curate deep nets for the DNN 
      * ***Description:*** The [DNN module](https://docs.opencv.org/trunk/d6/d0f/group__dnn.html) in OpenCV allows for accomplishing powerful high end vision tasks with just a [few lines of code](https://www.pyimagesearch.com/2017/08/21/deep-learning-with-opencv/). The goal of this project is to curate more models for ease of use by the OpenCV DNN module and put them in a place that they can be easily accessed such as LFS on Git. The mentor/admins will formalize the storage place.
      * ***Expected Outcomes:*** 
         * Read through the list of known to work models and major deepnet models in the resource list below. Come up with a target list of 6 new neural network models to add. 
         * For each deepnet model in turn
            * Use ONNX or other to allow the model to be run in DNN
            * Write a concise sample code and tutorial showing loading and use of that deepnet model
            * We will allocate a data store for your DNN enabled models so that they may be called by DNN and run. Put your models and other known to run models in this data store.
         * Resources
            * [DNN Tutorial](https://docs.opencv.org/master/d2/d58/tutorial_table_of_content_dnn.html)
            * [List of deepnets known to work with DNN](https://github.com/opencv/opencv/wiki/Deep-Learning-in-OpenCV)
            * [List of major deepnet models](https://github.com/kjw0612/awesome-deep-vision) 
            * [Code for DNN Module](https://github.com/opencv/opencv/tree/master/modules/dnn)
            * [LFS on Github](https://git-lfs.github.com/)
      * ***Skills Required:*** Coding in C++ and Python. Experience with deep neural networks.
      * ***Mentors:*** Stefano Fabri
      * ***Difficulty:*** Easy

   1. #### _IDEA:_ Add quantization and pruning functionality OpenCV DNN module
      * ***Description:*** "Learning compact models for object detection" added  SqueezeDet and SqueezeNet models to OpenCV repository. But OpenCV DNN module is still lacks high-level quantization and pruning functionality. Project also includes implementation of re-training (fine-tuning) of quantized and/or pruned models.
      * ***Expected Outcomes:*** 
         * 8-bit and 16-bit quantization implementation 
         * Iterative pruning with controlled by target sparsity
         * Provide examples of quantized and prunned network and fine-tune it (base is AlexNet or other classification architecture)
         * Provide evaluation of original network and compressed one (accuracy and speed)
         * Additional goals
            * N-bit quantization 
            * Different operation types as minifloat, dynamic fixed point etc.
            * Further model compression encoding/decoding with Huffman coding
         * Resources
            * https://arxiv.org/pdf/1806.08342.pdf
            * https://arxiv.org/pdf/1611.06440.pdf
      * ***Skills Required:*** Very good C++ coding skill, experience in Deep Learning area more than just tutorial, basic Computer Vision knowledge
      * ***Mentors:*** Tyan Vladimir
      * ***Difficulty:*** Medium-Hard 

   1. #### _IDEA:_ Deep Learning based Super-Resolution algorithms based on OpenCV DNN
      * ***Description:*** Project aims to build a super-resolution (SR) module inside OpenCV. Most probably base SR algorithms will be some Deep Learning algorithms (FSRCNN and EDSR) as recovering accuracy of DL algorithms is much better. But Computer Vision based algorithms also taken in consideration (A+ and etc.) if usefulness of their usage is proven in some terms except accuracy. 
      * ***Expected Outcomes:*** 
         * Build Super-Resolution module and implement interface for running different SR algorithms.
         * Add SR datasets to OpenCV datasets module
         * Implement FSRCNN algorithm (fast one) and train model on SR datasets
         * Implement EDSR algorithm (accurate one) and train model on SR datasets
         * Experiments and comparison of different models along with simple bicubic interpolation (or resize?) 
         * Additional goals
            * Implement Computer Vision SR algorithm (A+ and etc.)
         * Resources
            * https://arxiv.org/pdf/1608.00367.pdf
            * https://arxiv.org/pdf/1707.02921.pdf
            * https://www.vision.ee.ethz.ch/publications/papers/proceedings/eth_biwi_01165.pdf
      * ***Skills Required:*** Good C++ coding skill, experience in Deep Learning area, experience in  Computer Vision area
      * ***Mentors:*** Tyan Vladimir
      * ***Difficulty:*** Medium

1. ### Area: Differential operators
   1. #### _IDEA:_ Point Coordinate regression and DSAC.
      * ***Description:*** The task is to Implement a differentiable point coordinate regression and differentiable RANSAC into PyTorch Geometry. Open call to propose a differentiable decomposeHomography and help functions for R and T. Context: PyTorch Geometry is a partial reimplementation of OpenCV operators in a differentiable setup.
      * ***Expected Outcomes:*** 
         * Define and implement an API for proposed methods into PyTorch Geometry.
         * Define and implement DSAC as a generic framework (if possible) to the model (homography, pose, line, etc).
         * Provide unit test, gradient check tests.
         * Write sphinx documentation.
         * Write examples and notebook tutorials.
         * Resources
            * PyTorch Geometry https://github.com/arraiy/torchgeometry
            * point coordinate regression DSNT https://arxiv.org/abs/1801.07372 
https://github.com/anibali/dsntnn
            * differentiable randsac dsac https://github.com/vislearn/DSACLine
      * ***Skills Required:*** experience in geometry, computer vision and Python. You must know how to code using PyTorch and understanding about deep neural networks and the autograd engine.
      * ***Mentors:*** Clément Pinard http://perso.ensta-paristech.fr/~pinard/#
      * ***Difficulty:*** Medium/Hard

   1. #### _IDEA:_ Create a differentiable rendering module “torchgeometry.render”
      * ***Description:*** The task is to create a dedicated module into the PyTorch Geometry package based on the existing [Neural 3D Mesh Renderer framework](https://github.com/daniilidis-group/neural_renderer). Explore the framework and propose a solid API  with all the operators in order to provide as much as possible generic operators to solve computer graphics problems. Context: PyTorch Geometry is a partial reimplementation of OpenCV operators in a differentiable setup.
      * ***Expected Outcomes:*** 
         * Create a new module in torch geometry and propose an extens API based on the existing code.
         * Provide unit test, gradient check tests.
         * Write sphinx documentation.
         * Write examples and notebook tutorials.
         * Resources
            * PyTorch Geometry https://github.com/arraiy/torchgeometry
            * https://github.com/daniilidis-group/neural_renderer
      * ***Skills Required:*** experience in computer graphics, computer vision and Python. You must know how to code using PyTorch and understanding about deep neural networks and the autograd engine.
      * ***Mentors:*** Anatoly Baksheev
      * ***Difficulty:*** Medium/Hard

   1. #### _IDEA:_ Differentiable Image Processing
      * ***Description:*** Expand the existing PyTorch Geometry image processing module “torchgeometry.image”. The idea is to analyze what in OpenCV can be reimplemented in PyTorch in a differentiable manner and coexist with the framework. This will allow to run end-to-end Computer Vision pipelines reusing the computational graph, optimize with JIT or Tensor Comprehensions, run in distributed, etc. Context: PyTorch Geometry is a partial reimplementation of OpenCV operators in a differentiable setup.
      * ***Expected Outcomes:*** 
         * Explore the OpenCV API and propose what methods can be reimplemented fulfilling the above requirements.
         * Explore what’s in tensorflow image that can be used as a base API.
         * Match as much as possible OpenCV API.
            * Some ideas: sobel, laplacian filters, morphologic operators, color space conversions, etc.
         * Provide unit test, gradient check tests.
         * Write sphinx documentation.
         * Write examples and notebook tutorials.
         * Resources
            * PyTorch Geometry https://github.com/arraiy/torchgeometry
            * https://torchgeometry.readthedocs.io/en/latest/image.html
            * https://docs.opencv.org/master/d7/dbd/group__imgproc.html
      * ***Skills Required:*** experience in computer vision, and Python. You must know how to code using PyTorch and understanding about deep neural networks and the autograd engine.
      * ***Mentors:*** Edgar Riba
      * ***Difficulty:*** Medium/Hard

1. ### Area: Fiducials
   1. #### _IDEA:_ Add April Tag Fiducial detection to OpenCV
      * ***Description:*** April Tags are fiducial tabs that allow a geometric relation to camera pose via the 4 corners of the tags while yielding over 500 to several thousand uniquely readable tag patterns with error detecting codes. They are used extensively in camera calibration, object tracking, and robotics. They can be slow and hard to detect however. Add April Tags to OpenCV in a highly detectable and computationally efficient way by training MNet to recognize the tags and their corners and then using the April net algorithm at only one scale to find and confirm the ID of the tag.
      * ***Expected Outcomes:*** 
         * Train MNet to segment April tags to high performance under many views and lightings (Mentor will help with this)
            * It will detect corners in clockwise manner (even if 30% occluded)
            * It will detect ID even if 30% occluded
         * Move network into DNN
         * Use MNet to detect the ID and corners of tags, resize the tag to a canonical size and pass the corner locations and ID to the April Tag algorithm.
         * Modify the April Tag algorithm to take advantage of just one detection at a standard size and orientation together with an expected ID.
         * Resources
            * [April Tag paper](http://april.eecs.umich.edu/papers/details.php?name=olson2011tags)
            * [April Tags are described here](http://people.csail.mit.edu/kaess/apriltags/)
            * [April Tag C++ Code](https://github.com/swatbotics/apriltags-cpp)
            * [Academic Paper describing MNet](http://cdn.iiit.ac.in/cdn/cvit.iiit.ac.in/images/ConferencePapers/2017/jan_M-NET.pdf)
      * ***Mentors:*** Gary Bradski
      * ***Skills Required:*** Must and have experience using C++, Python and deep nets.
      * ***Difficulty:*** Hard. Must be able to train deep nets and use ONNX or other to port to DNN curated nets and then add a method for feeding in detected tags to the April tag algorithm (ported to OpenCV).

1. ### Area: Geometric Vision
   1. #### _IDEA:_ Create a Consolidated Optical Flow Module "optflow"
      * ***Description:*** Create a dedicated `optflow` module in the main repository consolidating the best available (within the library) collection of sparse and dense optical flow algorithms. We have LK optical flow, various sparse algorithms and the classical Farneback algorithm along with the better DIS optical flow. There may be some deep optical flow that's available in [OpenCV dnn samples](https://github.com/opencv/opencv/tree/master/samples/dnn).
      * ***Expected Outcomes:*** 
         * rename the [optflow module in opencv_contrib](https://github.com/opencv/opencv_contrib/tree/master/modules/optflow) to `optical_flow_experimental` 
         * Select the best optical flow modules (move those out of the former optflow in opencv_contrib)
         * Make a base class with standard method from which all optical flow estimators will derive. Some attempts to do that can already be found in [the video module](https://github.com/opencv/opencv/tree/master/modules/video)
         * Even though we consolidate API and move to the uniform object-oriented API, we need to keep the old API for backward compatibility (e.g. `cv::computeOptFlowFarneback` etc.).
         * Resources
            * [The feature request for this](https://github.com/opencv/opencv/wiki/OE-18.-Module-Optflow)
            * [The optical flow feature request](https://github.com/opencv/opencv/issues/11013)
            * [The optflow module in opencv_contrib](https://github.com/opencv/opencv_contrib/tree/master/modules/optflow) that includes some new optical flow algorithms.
      * ***Skills Required:*** mastery plus experience coding in C++, college course work in vision that covers optical flow, python. Best if you have also worked with deep neural networks.
      * ***Mentors:*** Vadim Pisarevsky
      * ***Difficulty:*** Medium (if you've worked with vision/opencv before)

1. ### Area: Programming Language/Web
   1. #### _IDEA:_ Improve and Expand Python Version of OpenCV
      * ***Description:*** The task is to create wrappers / code / tutorials for important modules and update / improve / expand existing tutorials for Python. This includes improving the documentation of newly added modules if required.
      * ***Expected Outcomes:*** 
         1. Add Python Wrappers for functions not present.
         1. Add python code for samples written in C++ only . [ C++ Samples ](https://github.com/opencv/opencv/tree/master/samples/cpp) , [ Python Samples ](https://github.com/opencv/opencv/tree/master/samples/python)
         1. Add tutorials for which Python code is already present as in [these python samples ](https://github.com/opencv/opencv/tree/master/samples/python)
         1. Combine Tutorials for C++ / Python etc into single directory and format the tutorial as shown in [this tutorial](https://docs.opencv.org/4.0.0/d1/d73/tutorial_introduction_to_svm.html). Details of documentation are [present here](https://github.com/opencv/opencv/blob/master/doc/tutorials/introduction/documenting_opencv/documentation_tutorial.markdown).
      * ***Skills Required:*** Mastery of C++ and python. Experience of creating python interface to C++ code. Fluent in written English.
      * ***Mentors:*** Ankit Sachan
      * ***Difficulty:*** Medium

   1. #### _IDEA:_ Improve the performance of JavaScript version of OpenCV (OpenCV.js)
      * ***Description:*** OpenCV.js makes OpenCV functions available to JavaScript developers by compiling its C++ implementation to WebAssembly (or Asm.js) and exposing them through a JavaScript binding. However the current version of OpenCV.js only runs in single thread and doesn't use SIMD instructions. This causes the performance of OpenCV.js is far below the native version and prevents some real-time use cases to be deployed in web browser. This task aims to improve the performance of OpenCV.js by exploiting parallelism of CPU. This requires to port the parallel implementations of OpenCV source code to web by leveraging Threads and SIMD features of WebAssembly.
      * ***Expected Outcomes:*** 
         * Speedup OpenCV.js by multi-threading
         * Speedup OpenCV.js by SIMD (using WASM)
         * Create OpenCV.js benchmark and profile the performance on multiple platforms
         * Create a real-time demo by leveraging parallel version of OpenCV.js
         * Resources
            * [OpenCV.js paper (including earlier experiments for parallelism by Web Worker and SIMD.js](https://dl.acm.org/citation.cfm?id=3204949.3208126)
            * [WebAssembly Threads](https://www.chromestatus.com/feature/5724132452859904)
            * [WebAssembly SIMD](https://www.chromestatus.com/feature/6533147810332672)
            * [JavaScript module](https://github.com/opencv/opencv/tree/master/modules/js)
            * [OpenCV.js tutorials](https://docs.opencv.org/master/d5/d10/tutorial_js_root.html)
      * ***Skills Required:*** C++, JavaScript, HTML, WebAssembly, performance optimization, multi-threading and SIMD. Fluent in written English.
      * ***Mentors:*** Ningxin Hu
      * ***Difficulty:*** Medium 

1. ### Area: SLAM / Camera Pose / RGBD / 3D reconstruction
   1. #### _IDEA:_ KinectFusion improvements
      * ***Description:***
         We have a KinectFusion 3d reconstruction algorithm which works reasonably well. However its practical use is limited by the list of reasons:
         - its space is limited and cannot extend as the camera moves
         - (connected to previous one) its space representation consumes too much memory
         - it cannot process non-rigid scenes like with living people or animals (even slight moves leaves running average artifacts)

         That's why there are 2 main ways of improvement:

         - Large scale implementations of the algorithm like Kintinuous or KinFu Large Scale
         - Implementing DynamicFusion which handles non-rigid scenes (seems more preferable because of already existing code from GSoC 2017)
         It's up to participant what way to choose.
      * ***Expected Outcomes:*** 
         GSoC participant is expected to build a version of the chosen algorithm that conforms to OpenCV standards:
         - it has (maybe slow) CPU version
         - it has tests w/ captured depth or rendered scene as it's done in OpenCV's KinFu version
         - it builds, it works and produces fine results at least on one dataset (better if this works in live mode)
         - it has as few dependencies as it is possible (ideal case is no dependencies outside of OpenCV)

         This should be done inside `rgbd` module as a separate class based on existing KinFu class.
         The set of methods may be extended by the ones to export resulting 3d model in any form (at least points+normals).

         * Resources
           - [DynamicFusion](https://grail.cs.washington.edu/projects/dynamicfusion/papers/DynamicFusion.pdf) which is able to handle non-rigidness by introducing local transformations
           - [Kintinuous](http://www.cs.nuim.ie/research/vision/data/rgbd2012/) large-scale version of KinFu which is based on pose-graph
           - [KinFu Large Scale](http://pointclouds.org/documentation/tutorials/using_kinfu_large_scale.php) this one is based on marching cubes
           - [rgbd module](https://github.com/opencv/opencv_contrib/tree/master/modules/rgbd) containing existing KinFu implementation
           - [previous attempt to make DynamicFusion](https://github.com/opencv/opencv_contrib/pull/1349)
           - [Dataset for non-rigid scene](http://lgdv.cs.fau.de/uploads/publications/data/innmann2016deform/umbrella_data.zip)
      * ***Skills Required:*** good understanding of 3d math, experienced in C++, experience in computer vision or image processing (at least one successful project), a lot of patience
      * ***Mentors:*** Rostislav Vasilikhin
      * ***Difficulty:*** from Hard to Extreme (based on the fact that there was one unsuccessful attempt in the past GSoC)
   1. #### _IDEA:_ _This is a placeholder:_ We may add an idea for Mobile SLAM 2/13/2019

1. ### Area: Tracking, Human Tracking, and Segmentation
   1. #### _IDEA:_ Facial Landmark Detector
      * ***Description:*** Facial feature detection and tracking is a high value area of computer vision since humans are interested in what humans are paying attention to, feeling, and enhancing face pictures in selfies etc. At this point, we feel this should just become a standard "built in" ability that computer vision users can just call/rely on. OpenCV already has some code available on for Facial Landmark detection, see [Tutorial on Facial Landmark Detector API](https://docs.opencv.org/4.0.0/d5/d47/tutorial_table_of_content_facemark.html) and  [Tutorials for face module](https://docs.opencv.org/4.0.0/de/d27/tutorial_table_of_content_face.html), but much progress has been made that we want to make available. The task is to create a Facial Landmark detector model with the following requirements:
      * ***Expected Outcomes:*** 
         * For mobile, make available a smaller model with lesser points ( e.g. 5 instead of 68 )
         * Run at better Accuracy than Dlib
         * Face Stabilization ( filtering and optical flow )
         * Add it to the Python API
         * Resources
            * https://docs.opencv.org/4.0.0/d5/d47/tutorial_table_of_content_facemark.html
            * https://docs.opencv.org/4.0.0/de/d27/tutorial_table_of_content_face.html
            * https://github.com/opencv/opencv_contrib/tree/master/modules/face
      * ***Skills Required:*** mastery level C++ and Python, college course work in Computer Vision that includes work on face features. Best if you have worked with deep networks before.
      * ***Mentors:*** Satya Mallick
      * ***Difficulty:*** Medium

   1. #### _IDEA:_ A universal boosted cascades interface
      * ***Description:*** Boosted cascades, before the era of deep learning, have long been the state-of-the-art for object detection and decision learning. When moving to OpenCV4 future releases, the plan is to remove them because of the old C-API backend and the tons of issues with the current implementation. This project will focus on re-implementing the boosted cascades, through an open and universal interface, that will allow applying these techniques, combined with newer feature generation algorithms like for example CNNS.
      * ***Expected Outcomes:*** 
         * Re-implement the boosted cascades / softcascades basic algorithm into OpenCV4.0 
         * Provide universal feature adding functionality: more than the previous HAAR/LBP/HOG 
         * Provide training, detection and evaluation interfaces
         * Resources
            * https://docs.opencv.org/3.4/dc/d88/tutorial_traincascade.html
            * https://github.com/opencv/opencv/tree/master/apps
      * ***Skills Required:*** efficient in C++ coding, college course work in classic computer vision, mediate experience in deep learning can help to include them as feature generators
      * ***Mentors:*** Steven Puttemans
      * ***Difficulty:*** Medium

1. ### Area: Tutorials

   1. #### _IDEA:_ Improve Machine Learning Tutorials and Documentation
      * ***Description:*** The **D**eep **N**eural **N**etwork (**DNN**) module is new and light on good tutorials. The **M**achine **L**earning (**ML**) Module is old and needs a tutorial refresh. The task is to create tutorials (code example applications and describe) for the machine learning/deep neural network modules and to update / improve / expand existing tutorials ( Mostly in C++ ) for the main OpenCV module as well as some opencv_contrib modules. This includes improving the documentation of newly added modules if required.

      * ***Expected Outcomes:*** 
         1. Write tutorials for DNN Module. 
            1. Code examples and create a tutorial on how the DNN module is structured and create a video explaining the important functions in the DNN module.
            1. Add code samples and write-ups on the usage of ONNX models.
            1. Search for real-time state-of-the-art models and port it to OpenCV.
         1. Improve and expand write-ups / videos for sample code already present in the repository but no tutorials. E.g.:
            1. [DNN](https://github.com/opencv/opencv/tree/master/samples/cpp)
               1. Image Classification using Tensorflow
               1. Object Detection using Tensorflow API
               1. Semantic Segmentation
               1. Image Colorization
               1. Neural Style Transfer
               1. OpenPose
            1. C++ code samples present in [opencv repo](https://github.com/opencv/opencv/tree/master/samples/cpp). e.g.
                  1. DIS Optical Flow
         1. Add code samples and write-ups for using different algorithms e.g.
            1. ML module
               1. Normal Bayes Classifier
               1. Decision Trees
               1. Random Forests
               1. ANN MLP
               1. K-NN
               1. K-Means
            1. Text Module in OpenCV Contrib
         1. Tutorial Series on using OpenVINO models and DLDT toolkit.
      * ***Skills Required:*** Excellent written English, Mastery level C++ knowledge, college course work in Computer Vision, Python knowledge. Working knowledge of deep neural networks.
      * ***Mentors:*** Vikas Gupta
      * ***Difficulty:*** Easy 

1. ### Area: User Interface
   1. #### _IDEA:_ Improve the OpenCV user interface
      * ***Description:*** [HighGUI](https://docs.opencv.org/master/d7/dfc/group__highgui.html) is OpenCV's graphical user interface including event triggering. It's cool, but it's old and needs revamping. HighGUI has been improved by using a QT interface at the cost of a large library to link in. We want to replace the QT functionality (mainly zoom to pixel and snapshot) with custom code. We'd also like to add native buttons.
      * ***Expected Outcomes:*** 
         * Drop QT dependency but retain at least zoom to pixel and snapshot capability with custom code
         * Add buttons as a native capability
         * Allow setting up an adaptive array of display windows w/in one larger window.
         * Retain ability for Python to call HighGUI
         * Resources
            * [High GUI documentation](https://docs.opencv.org/master/d7/dfc/group__highgui.html)
            * [High GUI tutorial](https://docs.opencv.org/3.4.0/d0/de2/tutorial_table_of_content_highgui.html)
      * ***Skills Required:*** C++, Python, user interface experience
      * ***Mentors:*** Vadim Pisarevsky
      * ***Difficulty:*** Easy if you are well familiar with GUI, Medium if not.

### Template
1. ### <Descriptive Category such as "Deep Nets">
   1. #### _IDEA:_ <Descriptive Title>
      * ***Description:*** 3-7 sentences describing the task
      * ***Expected Outcomes:*** 
         * < Short bullet list describing what is to be accomplished >
         * <i.e. create a new module called "bla bla">
         * < Has method to accomplish X >
         * <...>
         * Resources
            * [For example a paper citation](https://arxiv.org/pdf/1802.08091.pdf)
            * [For example an existing feature request](https://github.com/opencv/opencv/issues/11013)
            * [Possibly an existing related module](https://github.com/opencv/opencv_contrib/tree/master/modules/optflow) that includes some new optical flow algorithms.
      * ***Skills Required:*** < for example: mastery plus experience coding in C++, college course work in vision that covers optical flow, python. Best if you have also worked with deep neural networks. >
      * ***Mentors:*** < your name goes here >
      * ***Difficulty:*** <Easy, Medium, Hard> 

------------------

General Information:
--------------------
[ ▶️  **Join our OpenCV GSoC 2019 Mailing List** ◀️ ](https://groups.google.com/d/forum/opencv-gsoc-2019)
-  [Program Site for GSoC 2019](https://summerofcode.withgoogle.com/)
- Mailing list for OpenCV GSOC 2019: `opencv-gsoc-2019@googlegroups.com`
- IRC Channel: `#opencv` on freenode
- **Timelines**
    - [Timeline for GSoC 2019](https://summerofcode.withgoogle.com/how-it-works/#timeline)


### Important dates:

 Date (2019)              | Description                                                    | Comment
:------------------------:| -------------------------------------------------------------- | --------------
January 15        |Mentoring organizations begin submitting applications to Google  | :ok:
Feb 6	  | Mentoring organization application deadline                 | :ok:
February 26  | [Organizations Announced](https://summerofcode.withgoogle.com/organizations/5654472617885696/)  | :+1: **We are in!**
March 25 - April 9         | Student Applicaiton Period            |
April 9 - May 6   | Application Review Period        |
May 6	  | Student Projects Announced                               |
May 6 - 27	  | Community Bonding                                |
May 27 - ...	  | _Coding ..._                           |
June 24-28  | **Evaluation #1**                                                                          |
June 24 - ...	    | _Coding Continues ..._  |
July 22-26	  | **Evaluation #2**   |
July 22 - Aug 19	  | _Coding Continues ..._                                 |
Aug 19-26	          | Students submit final code and their evaluations       |
Aug 26-Sept 2	  | Mentors submit their **Final evaluation**   |
Sept 3	  | Results announced                                 |


### Times:

UTC to PDT (California uses PST in the winter (from Nov 1st) and PDT in the summer (from March 8)).

[UTC time](https://time.is/UTC)

[UTC time converter](http://www.timebie.com/std/gmt.php)

### Resources:

- [ OpenCV Project Ideas List](https://github.com/opencv/opencv/wiki/GSoC_2019#OpenCV-project-ideas-list)
- [OpenCV official Site](https://opencv.org)
- [OpenCV wiki](https://github.com/opencv/opencv/wiki)
- [Questions and Answers](http://answers.opencv.org/questions/)
- [[How to do a pull request/How to Contribute Code|How_to_contribute]]
- Source Code can be found at [GitHub/opencv](https://github.com/opencv/opencv) and [GitHub/opencv_contrib](https://github.com/opencv/opencv_contrib)
- [[Developer meeting notes|Meeting_notes]]

How you will be evaluated if you are an accepted student
--------------------------------------------------------

- Student projects to be paid only if:
    - **Phase 1:**
        - You must generate a pull request
            - That builds
            - Has at least stubbed out _(place holder functions such as just displaying an image)_ functionality
            - With OpenCV appropriate Doxygen documentation ([example tutorial](http://flcwiki.desy.de/How%20to%20document%20your%20code%20using%20doxygen))
                - Includes What the function or net is, what the function or net is used for 
            - Has at least stubbed out unit test
            - Has a stubbed out example/tutorial of use that builds
                 - See [the contribution guild](https://github.com/opencv/opencv/wiki/How_to_contribute)
                 - and [the coding style guild](https://github.com/opencv/opencv/wiki/Coding_Style_Guide)
                 - the [line_descriptor](https://github.com/opencv/opencv_contrib/tree/master/modules/line_descriptor) is a good example of student code
    - **Phase 2:**
        - You must generate a pull request
            - That builds
            - Has basic functionality
            - With OpenCV appropriate Doxygen documentation
                - Includes What the function or net is, what the function or net is used for 
            - Has basic unit test
            - Has a tutorial of how to use the function or net and why you'd want to use it.
    - **End of summer:**
        - A full pull request
            - Full Doxygen documentation
            - A good unit test
            - Example of use/tutorial of the code or net
        - Create a (short!) Movie (preferably on Youtube, but any movie) that demonstrates your code
            - We use this to create an overall summary. Past years:
                - [The 2015 Movie](https://www.youtube.com/watch?v=OUbUFn71S4s)
                - [The 2014 Movie](https://www.youtube.com/watch?v=3f76HCHJJRA)
                - [The 2013 Movie](https://www.youtube.com/watch?v=_TTtN4frMEA)

For students interested in applying
-----------------------------------

1.  You **must** already know how to program fluently in C++
    - Some projects may instead specifically require Python, javascript or Matlab skills
2.  Ask to join the opencv-gsoc mailing list above
    - Discuss projects ideas below or your own ideas with OpenCV mentors on the list.
    - Always title your proposal with what you want to do (example: *Implement Patch Match Stereo Algorithm* )
        - **NOTE:** The above is to discuss proposals with mentors. **BUT**, when the application period starts, you must still sign up with Google Summmer of Code and submit your proposal to the OpenCV organization. If not, you will not show up on the database where we can select you as a student.
3.  Sign up to be a student with OpenCV
4.  Post the project from below or your own agreed on project on the GSoC to opencv-gsoc mailing list above
    - Include Name, google email
    - Include how you think you are qualified to accomplish this project (skills, courses, relevant background)
    - Include Country of origin, school you are enrolled in, Professor you work with (if any)
    - Include a projected timeline and milestones for the project
5.  **When** we are told how many slots we will get **and** you've signed up for a project with us, **Then:**
    - We will weigh the students and projects against the mentors we gather and the mentor's interests and choose which students/project to pursue.
    - Accepted students will be posted on the GSoC site (and we will notify the accepted students ourselves afterwards).
    - Students are paid over the summer by Google **IF** the mentor accepts the student's work. There are several milestone based go-nogo points as above.
6.  We've had a lot of experience with this: Please only propose projects that you already know how to do. 
    - It is impossible for a mentor to train you in how to do the task while helping you do it. This **always** results in failure.
    - Mentors exist to keep you on track, and ensure good code, but not to teach you a new area of vision or AI.
    - This is also not a _research_ period. If you are a top student with publications in top conferences from a top professor in a top University known to us, we may let you code your research area. This is rare.
    - Documentation, tests and tutorial are as vital as the code. We'd rather have rougher code then miss these items because if these are not in place, your code will be useless to everyone.

For computer vision professionals interested in mentoring
---------------------------------------------------------

1.  Contact us on the opencv-gsoc googlegroups mailing list above and ask to be a mentor (or we will ask you in some known cases)
2.  If we accept you, we will post a request from the Google Summer of Code OpenCV project site asking you to join.
3.  You must accept the request and **you are a mentor!**
4.  You then:
    - Go to the opencv-gsoc googlegroups mailing list above and look through student project proposals, find a student and project you like and work with them to refine a realistic proposal that they can implement in a summer (you have to judge whether the student is capable - **you must verify that they can already code in the language (mostly C++) specified.** Summer is too short to learn to code and get something done).
        - you may also find (good) students and get them to apply, perhaps on your pet project idea
    - Once you find or create a project proposal that you want to mentor
        - several students might try for the same project
        - alternatively, you might have to convince a student to change projects to one you like or recruit an external student to join Google Summer of Code and apply to your project
    - But, always encourage students to officially apply through the Google Summer of Code site
5.  Then, when we get a slot allocation from Google, the administrators *"spend"* the slots in order of priority influenced by whether there's a capable mentor or not for each topic.
6.  Students must finally actually accept to do that project (some sign up for multiple organizations and then choose)
    - Sheesh!

**If** you are accepted as a mentor **and** you find a suitable student **and** we give you a slot **and** the student signs up for it, **then** you are an actual mentor! Otherwise you are **not a mentor** and have no other obligations. 
   - Thank you for trying. 
   - You may contact other mentors and co-mentor a project.

It sounds harder than it is.

You get paid a modest stipend over the summer to mentor, typically $500 minus an org fee of 6%.

Several mentors donate their salary, earning ever better positions in heaven when that comes.


Accepted Projects and Mentors
=============================

Alphabetic by project title

Student | Title | Mentor(s)
--------|-------|-----------

-------------------------------------------------------------------------------------------------
# Staff

## Admins
```
Gary Bradski
   CTO Arraiy, CEO/Co-founder OpenCV
   Co-founder of OpenCV
   Organized the Vision Team for Stanley the Robot that 
      won the 2005 DARPA Grand Challenge and started 
      the autonomous driving industry. Now in the 
      Smithsonian Museum
   Startups (leading role):
      Video Surf -- Founding shares, sold to Microsoft 2010
      Industrial Perception -- Founder, CTO sold to Google 2013
      Magic Leap -- Founded Silicon Valley office, built to 110 employees
      Arraiy -- Founder CTO
      garybradski(+)gmail.com
Vadim Pisarevsky
    OpenCV team lead at Intel
    Co-founder of OpenCV
    Former principal engineer at Itseez.inc, then principal engineer at Intel
    vadim.pisarevsky(+)gmail.com
```

## Potential mentors

```
- Alexander Mordvintsev zzznah(+)gmail.com
- Sid Bao baoyingze(+)gmail.com
- Vincent Rabaud vincent.rabaud(+)gmail.com
- Vadim Pisarevsky vadim.pisarevsky(+)gmail.com
- Maksim Shabunin maksim.shabunin(+)gmail.com
- Dmitry Kurtaev dmitry.kurtaev(+)gmail.com
- Alexander Nesterov alexander.nesterov(+)gmail.com
- Vitaly Tuzov vitaly.tuzov(+)gmail.com
- Terry Boult tboult(+)vast.uccs.edu
- spmallick spmallick(+)taaz.com
- Serge Belongie sjb344(+)cornell.edu
- Stefano s.fabri10(+)gmail.com
- Pablo Alcantarilla pablofdezalc(+)gmail.com
- Bence Magyar mw.mzperx(+)gmail.com
- Manuele manuele.tamburrano(+)gmail.com
- Grace Vesom grace.vesom(+)gmail.com
- Open Source Computer Vision Library (OpenCV) garybradski(+)gmail.com
- Douglas Lee dougabug(+)gmail.com
- Claudia Rapuano c.rapuano(+)gmail.com
- Antonella Cascitelli antonellacascitelli(+)gmail.com
- Alexander Smorkalov alexander.smorkalov(+)intel.com
- Alexander Bovyrin alexander.bovyrin(+)intel.com
- Ningxin Hu ningxin.hu(+)intel.com
```